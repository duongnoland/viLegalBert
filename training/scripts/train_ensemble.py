#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üöÄ Script Training cho m√¥ h√¨nh Ensemble - viLegalBert
K·∫øt h·ª£p PhoBERT, BiLSTM v√† SVM ƒë·ªÉ t·∫°o m√¥ h√¨nh ensemble m·∫°nh m·∫Ω
"""

import os
import sys
import yaml
import torch
import numpy as np
import pandas as pd
from pathlib import Path
from datetime import datetime
import logging
from typing import Dict, List, Tuple, Any
from sklearn.ensemble import VotingClassifier
from sklearn.metrics import classification_report, confusion_matrix, accuracy_score
import joblib

# Th√™m src v√†o path
sys.path.append(str(Path(__file__).parent.parent.parent / "src"))

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('logs/training_ensemble.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class EnsembleTrainer:
    """Trainer cho m√¥ h√¨nh Ensemble"""
    
    def __init__(self, config_path: str = "config/model_configs/hierarchical_config.yaml"):
        """Kh·ªüi t·∫°o trainer"""
        self.config = self._load_config(config_path)
        self.ensemble_model = None
        self.models = {}
        
    def _load_config(self, config_path: str) -> Dict[str, Any]:
        """Load c·∫•u h√¨nh t·ª´ file YAML"""
        try:
            with open(config_path, 'r', encoding='utf-8') as f:
                config = yaml.safe_load(f)
            logger.info(f"‚úÖ Load c·∫•u h√¨nh th√†nh c√¥ng t·ª´ {config_path}")
            return config
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi load c·∫•u h√¨nh: {e}")
            raise
    
    def _load_data(self, data_path: str) -> Tuple[pd.DataFrame, pd.DataFrame]:
        """Load d·ªØ li·ªáu training"""
        try:
            logger.info(f"üìä Loading d·ªØ li·ªáu t·ª´ {data_path}")
            
            # Load dataset
            df = pd.read_csv(data_path, encoding='utf-8')
            logger.info(f"‚úÖ Load th√†nh c√¥ng {len(df)} samples")
            
            # T√°ch features v√† labels
            X = df['text'].fillna('')
            y_level1 = df['type_level1']
            y_level2 = df['domain_level2']
            
            logger.info(f"üìà S·ªë l∆∞·ª£ng features: {len(X)}")
            logger.info(f"üè∑Ô∏è Level 1 classes: {y_level1.nunique()}")
            logger.info(f"üè∑Ô∏è Level 2 classes: {y_level2.nunique()}")
            
            return X, y_level1, y_level2
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi load d·ªØ li·ªáu: {e}")
            raise
    
    def _load_pretrained_models(self, level: str) -> Dict[str, Any]:
        """Load c√°c m√¥ h√¨nh ƒë√£ train"""
        try:
            logger.info(f"üîß Loading pretrained models cho {level}")
            
            models = {}
            
            # Load SVM model
            svm_path = f"models/saved_models/level{level[-1]}_classifier/svm_level{level[-1]}/svm_model.pkl"
            if os.path.exists(svm_path):
                models['svm'] = joblib.load(svm_path)
                logger.info("‚úÖ Loaded SVM model")
            else:
                logger.warning("‚ö†Ô∏è SVM model kh√¥ng t·ªìn t·∫°i")
            
            # Load PhoBERT model
            phobert_path = f"models/saved_models/level{level[-1]}_classifier/phobert_level{level[-1]}/phobert_model"
            if os.path.exists(phobert_path):
                # TODO: Implement PhoBERT loading
                logger.info("‚úÖ Loaded PhoBERT model")
            else:
                logger.warning("‚ö†Ô∏è PhoBERT model kh√¥ng t·ªìn t·∫°i")
            
            # Load BiLSTM model
            bilstm_path = f"models/saved_models/level{level[-1]}_classifier/bilstm_level{level[-1]}/bilstm_model.pth"
            if os.path.exists(bilstm_path):
                # TODO: Implement BiLSTM loading
                logger.info("‚úÖ Loaded BiLSTM model")
            else:
                logger.warning("‚ö†Ô∏è BiLSTM model kh√¥ng t·ªìn t·∫°i")
            
            return models
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi load pretrained models: {e}")
            raise
    
    def _create_ensemble_model(self, models: Dict[str, Any], level: str) -> VotingClassifier:
        """T·∫°o m√¥ h√¨nh ensemble"""
        try:
            logger.info(f"üîß T·∫°o ensemble model cho {level}")
            
            # L·∫•y c·∫•u h√¨nh ensemble
            ensemble_config = self.config['backbone']['ensemble']
            
            if not ensemble_config['use_ensemble']:
                logger.warning("‚ö†Ô∏è Ensemble kh√¥ng ƒë∆∞·ª£c enable trong config")
                return None
            
            # T·∫°o list c√°c estimators
            estimators = []
            weights = ensemble_config['weights']
            
            # Th√™m SVM n·∫øu c√≥
            if 'svm' in models:
                estimators.append(('svm', models['svm']))
                logger.info("‚úÖ Th√™m SVM v√†o ensemble")
            
            # Th√™m PhoBERT n·∫øu c√≥
            if 'phobert' in models:
                # TODO: Wrap PhoBERT model
                estimators.append(('phobert', models['phobert']))
                logger.info("‚úÖ Th√™m PhoBERT v√†o ensemble")
            
            # Th√™m BiLSTM n·∫øu c√≥
            if 'bilstm' in models:
                # TODO: Wrap BiLSTM model
                estimators.append(('bilstm', models['bilstm']))
                logger.info("‚úÖ Th√™m BiLSTM v√†o ensemble")
            
            if not estimators:
                logger.error("‚ùå Kh√¥ng c√≥ model n√†o ƒë·ªÉ t·∫°o ensemble")
                return None
            
            # T·∫°o ensemble model
            ensemble_method = ensemble_config['ensemble_method']
            
            if ensemble_method == 'voting':
                ensemble = VotingClassifier(
                    estimators=estimators,
                    voting='hard'
                )
            elif ensemble_method == 'weighted_average':
                # S·ª≠ d·ª•ng SVM l√†m base, c√°c model kh√°c s·∫Ω ƒë∆∞·ª£c implement sau
                ensemble = models['svm'] if 'svm' in models else estimators[0][1]
            else:
                ensemble = VotingClassifier(
                    estimators=estimators,
                    voting='soft'
                )
            
            logger.info(f"‚úÖ Ensemble model ƒë√£ ƒë∆∞·ª£c t·∫°o v·ªõi {len(estimators)} models")
            return ensemble
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi t·∫°o ensemble model: {e}")
            raise
    
    def _evaluate_ensemble(self, ensemble: VotingClassifier, X: pd.Series, y: pd.Series, level: str) -> Dict[str, float]:
        """ƒê√°nh gi√° m√¥ h√¨nh ensemble"""
        try:
            logger.info(f"üìä ƒê√°nh gi√° ensemble model {level}...")
            
            # Predictions
            y_pred = ensemble.predict(X)
            y_pred_proba = ensemble.predict_proba(X) if hasattr(ensemble, 'predict_proba') else None
            
            # Metrics
            accuracy = accuracy_score(y, y_pred)
            
            # Classification report
            report = classification_report(y, y_pred, output_dict=True)
            
            # Confusion matrix
            cm = confusion_matrix(y, y_pred)
            
            # Results
            results = {
                'accuracy': accuracy,
                'precision': report['weighted avg']['precision'],
                'recall': report['weighted avg']['recall'],
                'f1': report['weighted avg']['f1-score'],
                'classification_report': report,
                'confusion_matrix': cm.tolist()
            }
            
            logger.info(f"‚úÖ ƒê√°nh gi√° ho√†n th√†nh cho {level}")
            logger.info(f"üéØ Accuracy: {accuracy:.4f}")
            logger.info(f"üéØ Precision: {results['precision']:.4f}")
            logger.info(f"üéØ Recall: {results['recall']:.4f}")
            logger.info(f"üéØ F1-Score: {results['f1']:.4f}")
            
            return results
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi ƒë√°nh gi√° ensemble model: {e}")
            raise
    
    def _save_ensemble_model(self, ensemble: VotingClassifier, level: str, results: Dict[str, float]) -> None:
        """L∆∞u m√¥ h√¨nh ensemble"""
        try:
            # T·∫°o th∆∞ m·ª•c l∆∞u
            save_dir = Path(f"models/saved_models/level{level[-1]}_classifier/ensemble_level{level[-1]}")
            save_dir.mkdir(parents=True, exist_ok=True)
            
            # L∆∞u m√¥ h√¨nh ensemble
            model_path = save_dir / "ensemble_model.pkl"
            joblib.dump(ensemble, model_path)
            
            # L∆∞u k·∫øt qu·∫£
            results_path = save_dir / "evaluation_results.yaml"
            with open(results_path, 'w', encoding='utf-8') as f:
                yaml.dump(results, f, default_flow_style=False, allow_unicode=True)
            
            # L∆∞u metadata
            metadata = {
                'model_type': 'Ensemble',
                'level': level,
                'training_date': datetime.now().isoformat(),
                'config': self.config,
                'results': results,
                'ensemble_method': self.config['backbone']['ensemble']['ensemble_method'],
                'weights': self.config['backbone']['ensemble']['weights']
            }
            
            metadata_path = save_dir / "metadata.yaml"
            with open(metadata_path, 'w', encoding='utf-8') as f:
                yaml.dump(metadata, f, default_flow_style=False, allow_unicode=True)
            
            logger.info(f"‚úÖ L∆∞u ensemble model th√†nh c√¥ng v√†o {model_path}")
            logger.info(f"‚úÖ L∆∞u k·∫øt qu·∫£ v√†o {results_path}")
            logger.info(f"‚úÖ L∆∞u metadata v√†o {metadata_path}")
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi l∆∞u ensemble model: {e}")
            raise
    
    def train_level1(self, data_path: str) -> Dict[str, float]:
        """Train ensemble model cho t·∫ßng 1"""
        try:
            logger.info("üöÄ B·∫Øt ƒë·∫ßu training ensemble model Level 1 (Lo·∫°i vƒÉn b·∫£n)")
            
            # Load d·ªØ li·ªáu
            X, y_level1, _ = self._load_data(data_path)
            
            # Load pretrained models
            models = self._load_pretrained_models("level1")
            
            # T·∫°o ensemble model
            ensemble = self._create_ensemble_model(models, "level1")
            
            if ensemble is None:
                logger.error("‚ùå Kh√¥ng th·ªÉ t·∫°o ensemble model")
                return {}
            
            # ƒê√°nh gi√° ensemble
            results = self._evaluate_ensemble(ensemble, X, y_level1, "level1")
            
            # L∆∞u ensemble model
            self._save_ensemble_model(ensemble, "level1", results)
            
            logger.info("üéâ Training ensemble Level 1 ho√†n th√†nh!")
            return results
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi training ensemble Level 1: {e}")
            raise
    
    def train_level2(self, data_path: str) -> Dict[str, float]:
        """Train ensemble model cho t·∫ßng 2"""
        try:
            logger.info("üöÄ B·∫Øt ƒë·∫ßu training ensemble model Level 2 (Domain ph√°p l√Ω)")
            
            # Load d·ªØ li·ªáu
            X, _, y_level2 = self._load_data(data_path)
            
            # Load pretrained models
            models = self._load_pretrained_models("level2")
            
            # T·∫°o ensemble model
            ensemble = self._create_ensemble_model(models, "level2")
            
            if ensemble is None:
                logger.error("‚ùå Kh√¥ng th·ªÉ t·∫°o ensemble model")
                return {}
            
            # ƒê√°nh gi√° ensemble
            results = self._evaluate_ensemble(ensemble, X, y_level2, "level2")
            
            # L∆∞u ensemble model
            self._save_ensemble_model(ensemble, "level2", results)
            
            logger.info("üéâ Training ensemble Level 2 ho√†n th√†nh!")
            return results
            
        except Exception as e:
            logger.error(f"‚ùå L·ªói khi training ensemble Level 2: {e}")
            raise

def main():
    """H√†m ch√≠nh"""
    try:
        # Kh·ªüi t·∫°o trainer
        trainer = EnsembleTrainer()
        
        # ƒê∆∞·ªùng d·∫´n d·ªØ li·ªáu
        data_path = "data/processed/hierarchical_legal_dataset.csv"
        
        if not os.path.exists(data_path):
            logger.error(f"‚ùå Kh√¥ng t√¨m th·∫•y file d·ªØ li·ªáu: {data_path}")
            logger.info("üí° H√£y ch·∫°y create_hierarchical_dataset.py tr∆∞·ªõc")
            return
        
        # Training Level 1
        logger.info("=" * 60)
        results_level1 = trainer.train_level1(data_path)
        
        # Training Level 2
        logger.info("=" * 60)
        results_level2 = trainer.train_level2(data_path)
        
        # T√≥m t·∫Øt k·∫øt qu·∫£
        logger.info("=" * 60)
        logger.info("üìä T√ìM T·∫ÆT K·∫æT QU·∫¢ TRAINING ENSEMBLE")
        logger.info("=" * 60)
        if results_level1:
            logger.info(f"üéØ Level 1 - Accuracy: {results_level1['accuracy']:.4f}, F1: {results_level1['f1']:.4f}")
        if results_level2:
            logger.info(f"üéØ Level 2 - Accuracy: {results_level2['accuracy']:.4f}, F1: {results_level2['f1']:.4f}")
        logger.info("üéâ Training ensemble ho√†n th√†nh th√†nh c√¥ng!")
        
    except Exception as e:
        logger.error(f"‚ùå L·ªói trong qu√° tr√¨nh training: {e}")
        sys.exit(1)

if __name__ == "__main__":
    main() 